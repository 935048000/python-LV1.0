"""

包含字母的消息A-Z正在使用以下映射方式编码为数字：
'A' -> 1
'B' -> 2
...
'Z' -> 26

除此之外，现在编码的字符串还可以包含字符“*”，可以被视为从1到9之一的数字。

给定包含数字和字符'*'的编码消息，返回解码方法的总数。
另外，由于答案可能非常大，因此应该返回输出mod 10^9 + 7。



解法：
e0 = 目前我们可以解码的方式有多少，以任何数字结尾;
e1 = 目前我们可以解码的方式有多少，以一个开放的1结束;
e2 = 目前我们可以解码的方法有多少，最后是一个开放的2;
（在这里，“打开1”是指稍后可以用作2位数字的第一位的1，因为在前面的2位数字中没有使用它。）

我们看到一些字符c。我们要计算f0, f1, f2，e0, e1, e2解析后的字符对应的版本c。

如果c == '*'，那么的方式共完成号码是：
我们可以把*作为一个单一的数字（9*e0），或者我们可以配对*为2位数1*的9*e1方式，
或者我们可以配对*为2位数2*的6*e2方式。完成开放1（或2）的方法的数量是正确的e0。

如果c != '*'总共完成的方法是：
c如果不是零（(c>'0')*e0），我们可以把它作为一个数字，或者我们可以c与我们的开放1配对，
或者c如果它是6 ，我们可以与我们的开放2 配对。
少（(c<='6')*e2）。
结束1（或2）的方法的数量是e0iff c == '1'（或c == '2'）。
"""

def numDecodings(S):
    MOD = 10**9 + 7
    e0, e1, e2 = 1, 0, 0
    for c in S:
        if c == '*':
            f0 = 9*e0 + 9*e1 + 6*e2
            f1 = e0
            f2 = e0
        else:
            f0 = (c > '0') * e0 + e1 + (c <= '6') * e2
            f1 = (c == '1') * e0
            f2 = (c == '2') * e0
        e0, e1, e2 = f0 % MOD, f1, f2
    return e0


print(numDecodings("13"))






